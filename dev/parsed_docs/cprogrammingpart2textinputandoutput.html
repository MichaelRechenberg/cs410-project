Use printf. The first parameter is a format string that includes placeholders for the data to be printed. Common format specifiers are %s treat the argument as a c string pointer, keep printing all characters until the NULL-character is reached; %d print the argument as an integer; %p print the argument as a memory address. 
A simple example is shown below:
By default, for performance, printf does not actually write anything out (by calling write) until its buffer is full or a newline is printed. 
Use puts( name ); and putchar( c )  where name is a pointer to a C string and c is just a char
Use fprintf( _file_ , "Hello %s, score: %d", name, score);
Where _file_ is either predefined 'stdout' 'stderr' or a FILE pointer that was returned by fopen or fdopen
Use sprintf or better snprintf.
snprintf returns the number of characters written excluding the terminating byte. In the above example this would be a maximum of 199.
Use scanf (or fscanf or sscanf) to get input from the default input stream, an arbitrary file stream or a C string respectively.
It's a good idea to check the return value to see how many items were parsed.
scanf functions require valid pointers. It's a common source of error to pass in an incorrect pointer value. For example,
We wanted to write the character value into c and the integer value into the malloc'd memory.
However we passed the address of the data pointer, not what the pointer is pointing to! So sscanf will change the pointer itself. i.e. the pointer will now point to address 10 so this code will later fail e.g. when free(data) is called.
The following code assumes the scanf won't read more than 10 characters (including the terminating byte) into the buffer.
You can include an optional integer to specify how many characters EXCLUDING the terminating byte:
The following code is vulnerable to buffer overflow. It assumes or trusts that the input line will be no more than 10 characters, including the terminating byte.
gets is deprecated and will be removed in future versions of the C standard. Programs should use fgets or getline instead. 
Where each have the following structure respectively:
Here's a simple, safe way to read a single line. Lines longer than 9 characters will be truncated:
The result is NULL if there was an error or the end of the file is reached.
Note, unlike gets,  fgets copies the newline into the buffer, which you may want to discard-
One of the advantages of getline is that will automatically (re-) allocate a buffer on the heap of sufficient size.
How do I print strings, ints, chars to the standard output stream?
How else can I print strings and single characters?
How do I print to other file streams?
How do I print data into a C string?
How do I parse input using scanf into parameters?
How do I stop scanf from causing a buffer overflow?
Why is gets dangerous? What should I use instead?
How do I use getline?
C Programming, Part 2: Text Input And Output
C Programming, Part 2: Text Input And Output
