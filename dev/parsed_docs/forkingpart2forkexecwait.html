There's no error checking in the above code (we assume close,open,chdir etc works as expected).
 open: will use the lowest available file descriptor (i.e. 1) ; so standard out now goes to the log file.
 chdir : Change the current directory to /usr/include
 execl : Replace the program image with /bin/ls and call its main() method
 perror : We don't expect to get here - if we did then exec failed.
See the fork man page for more details.
The process id is different. In the child calling getppid() (notice the two 'p's) will give the same result as calling getpid() in the parent. See the fork man page for more details.
Use waitpid or wait. The parent process will pause until wait (or waitpid) returns. Note this explanation glosses over the restarting discussion.
A common programming pattern is to call fork followed by exec and wait. The original process calls fork, which creates a child process. The child process then uses exec to start execution of a new program. Meanwhile the parent uses wait (or waitpid) to wait for the child process to finish.
See below for a complete code example.
Don't wait for them! Your parent process can continue to execute code without having to wait for the child process. Note in practice background processes can also be disconnected from the parent's input and output streams by calling close on the open file descriptors before calling exec.
However child processes that finish before their parent finishes can become zombies. See the zombie page for more information.
When a child finishes (or terminates) it still takes up a slot in the kernel process table. 
Only when the child has been 'waited on' will the slot be available again.
A long running program could create many zombies by continually creating processes and never wait-ing for them.
Eventually there would be insufficient space in the kernel process table to create a new processes. Thus fork() would fail and could make the system difficult / impossible to use - for example just logging in requires a new process!
Once a process completes, any of its children will be assigned to "init" - the first process with pid of 1. Thus these children would see getppid() return a value of 1. The init process automatically waits for all of its children, thus removing zombies from the system.
Wait on your child!
Note we assume that the only reason to get a SIGCHLD event is that a child has finished (this is not quite true - see man page for more details).
A robust implementation would also check for interrupted status and include the above in a loop.
Read on for a discussion of a more robust implementation.
Warning: This section uses signals which we have not yet fully introduced.
The parent gets the signal SIGCHLD when a child completes, so the signal handler can wait on the process. A slightly simplified version is shown below.
The above example however misses a couple of subtle points:
 More than one child may have finished but the parent will only get one SIGCHLD signal (signals are not queued)
 SIGCHLD signals can be sent for other reasons (e.g. a child process is temporarily stopped)
A more robust code to reap zombies is shown below.
What does the following 'exec' example do?
What does the child inherit from the parent?
What is different in the child process than the parent process?
How do I wait for my child to finish?
What is the fork-exec-wait pattern
How do I start a background process that runs as the same time?
Good parents don't let their children become zombies!
What would be effect of too many zombies?
What does the system do to help prevent zombies?
How do I prevent zombies? (Warning: Simplified answer)
How can I asynchronously wait for my child using SIGCHLD? (ADVANCED)
Forking, Part 2: Fork, Exec, Wait
Forking, Part 2: Fork, Exec, Wait
