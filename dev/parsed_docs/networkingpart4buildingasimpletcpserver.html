Integers can be represented in least significant byte first or most-significant byte first. Either approach is reasonable as long as the machine itself is internally consistent. For network communications we need to standardize on agreed format.
htons(xyz) returns the 16 bit unsigned integer 'short' value xyz in network byte order.
htonl(xyz) returns the 32 bit unsigned integer 'long' value xyz in network byte order.
These functions are read as 'host to network'; the inverse functions (ntohs, ntohl) convert network ordered byte values to host-ordered ordering. So, is host-ordering  little-endian or big-endian? The answer is - it depends on your machine! It depends on the actual architecture of the host running the code. If the architecture happens to be the same as network ordering then the result of these functions is just the argument. For x86 machines, the host and network ordering is different.
Summary: Whenever you read or write the low level C network structures (e.g. port and address information), remember to use the above functions to ensure correct conversion to/from a machine format. Otherwise the displayed or specified value may be incorrect.
The four system calls required to create a TCP server are: socket, bind listen and accept. Each has a specific purpose and should be called in the above order
The port information (used by bind) can be set manually (many older IPv4-only C code examples do this), or be created using getaddrinfo
We also see examples of setsockopt later too.
To create a endpoint for networking communication. A new socket by itself is not particularly useful; though we've specified either a packet or stream-based connections it is not bound to a particular network interface or port. Instead socket returns a network descriptor that can be used with later calls to bind,listen and accept.
The bind call associates an abstract socket with an actual network interface and port. It is possible to call bind on a TCP client however it's unusually unnecessary to specify the outgoing port.
The listen call specifies the queue size for the number of incoming, unhandled connections i.e. that have not yet been assigned a network descriptor by accept
Typical values for a high performance server are 128 or more.
Server sockets do not actively try to connect to another host; instead they wait for incoming connections. Additionally, server sockets are not closed when the peer disconnects. Instead when a remote client connects, it is immediately bumped to an unused port number for future communications.
Once the server socket has been initialized the server calls accept to wait for new connections. Unlike socket bind and listen, this call will block. i.e. if there are no new connections, this call will block and only return when a new client connects.
Note the accept call returns a new file descriptor. This file descriptor is specific to a particular client. It is common programming mistake to use the original server socket descriptor for server I/O and then wonder why networking code has failed.
Note, ports are per machine- not per process or per user. In other words,  you cannot use port 1234 while another process is using that port. Worse, ports are by default 'tied up' after a process has finished.
A working simple server example is shown below. Note this example is incomplete - for example it does not close either socket descriptor, or free up memory created by getaddrinfo
By default a port is not immediately released when the socket is closed. Instead, the port enters a "TIMED-WAIT" state. This can lead to significant confusion during development because the timeout can make valid networking code appear to fail.
To be able to immediately re-use a port, specify SO_REUSEPORT before binding to the port.
Here's an extended stackoverflow introductory discussion of SO_REUSEPORT.
What is htons and when is it used?
What are the 'big 4' network calls used to create a server?
What is the purpose of calling socket?
What is the purpose of calling bind
What is the purpose of calling listen
Why are server sockets passive?
What is the purpose of calling accept
What are the gotchas of creating a TCP-server?
Server code example
Why can't my server re-use the port?
Networking, Part 4: Building a simple TCP Server
Networking, Part 4: Building a simple TCP Server
