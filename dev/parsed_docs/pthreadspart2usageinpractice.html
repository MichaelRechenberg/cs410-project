See Pthreads Part 1 which introduces pthread_create and pthread_join
Your process will contain three stacks - one for each thread. The first thread is created when the process starts and you created two more. Actually there can be more stacks than this but let's ignore that complication for now. The important idea is that each thread requires a stack because the stack contains automatic variables and the old CPU PC register so that it can back to executing the calling function after the function is finished.
In addition, unlike processes, threads within the same process can share the same global memory (data and heap segments).
Stops a thread. Note the thread may not actually be stopped immediately. For example it can be terminated when the thread makes an operating system call (e.g. write).
In practice pthread_cancel is rarely used because it does not give a thread an opportunity to clean up after itself (for example, it may have opened some files).
An alternative implementation is to use a boolean (int) variable whose value is used to inform other threads that they should finish and clean up.
exit(42) exits the entire process and sets the processes exit value.  This is equivalent to return 42 in the main method. All threads inside the process are stopped.
pthread_exit(void *) only stops the calling thread i.e. the thread never returns after calling pthread_exit. The pthread library will automatically finish the process if there are no other threads running. pthread_exit(...) is equivalent to returning from the thread's function; both finish the thread and also set the return value (void *pointer) for the thread.
Calling pthread_exit in the the main thread is a common way for simple programs to ensure that all threads finish. For example, in the following program, the  myfunc threads will probably not have time to get started.
The next two programs will wait for the new threads to finish-
Alternatively, we join on each thread (i.e. wait for it to finish) before we return from main (or call exit).
Note the pthread_exit version creates thread zombies, however this is not a long-running processes, so we don't care.
Finished threads will continue to consume resources. Eventually, if enough threads are created, pthread_create will fail.
In practice, this is only an issue for long-runnning processes but is not an issue for simple, short-lived processes as all thread resources are automatically freed when the process exits.
Both pthread_exit and pthread_join will let the other threads finish on their own (even if called in the main thread). However, only pthread_join will return to you when the specified thread finishes. pthread_exit does not wait and will immediately end your thread and give you no chance to continue executing.
Yes. However you need to be very careful about the lifetime of stack variables.
The above code is invalid because the function start_threads will likely return before myfunc even starts. The function passes the address-of start, however by the time myfunc is executes, start is no longer in scope and its address will re-used for another variable.
The following code is valid because the lifetime of the stack variable is longer than the background thread.
The following code is supposed to start ten threads with values 0,1,2,3,...9
However, when run prints out 1 7 8 8 8 8 8 8 8 10! Can you see why?
The above code suffers from a race condition - the value of i is changing. The new threads start later (in the example output the last thread starts after the loop has finished).
To overcome this race-condition, we will give each thread a pointer to it's own data area. For example, for each thread we may want to store the id, a starting value and an output value:
These can be stored in an array - 
And each array element passed to each thread - 
To answer this, let's look at a simple function that is also not 'thread-safe'
In the above code the result buffer is stored in global memory. This is good - we wouldn't want to return a pointer to an invalid address on the stack, but there's only one result buffer in the entire memory. If two threads were to use it at the same time then one would corrupt the other:
These are synchronization locks that are used to prevent race conditions and ensure proper synchronization between threads running in the same program. In addition these locks are conceptually identical to the primitives used inside the kernel.
Yes! Sharing information between threads is easy because threads (of the same process) live inside the same virtual memory space.
Also, creating a thread is significantly faster than creating(forking) a process.
Yes! No- isolation! As threads live inside the same process, one thread has access to the same virtual memory as the other threads. A single thread can terminate the entire process (e.g. by trying to read address zero).
Yes! However the child process only has a single thread (which is a clone of the thread that called fork. We can see this as a simple example, where the background threads never print out a second message in the child process.
In practice creating threads before forking can lead to unexpected errors because (as demonstrated above) the other threads are immediately terminated when forking. Another thread might have just lock a mutex (e.g. by calling malloc) and never unlock it again. Advanced users may find pthread_atfork useful however we suggest you usually try to avoid creating threads before forking unless you fully understand the limitations and difficulties of this approach.
Creating separate processes is useful 
 When more security is desired (for example, Chrome browser uses different processes for different tabs)
 When running an existing and complete program then a new process is required (e.g. starting 'gcc')
See the complete example in the man page
And the pthread reference guide
ALSO: Concise third party sample code explaining create, join and exit
How do I create a pthread?
If I call pthread_create twice how many stacks does my process have?
What is the difference between a process and a thread?
What does pthread_cancel do?
What is the difference between exit and pthread_exit?
How can a thread be terminated?
What is the purpose of pthread_join?
What happens if you don't call pthread_join?
Should I use pthread_exit or pthread_join?
Can you pass pointers to stack variables from one thread to another?
How can I create ten threads with different starting values.
Why are some functions e.g.  asctime,getenv, strtok, strerror  not thread-safe?
What are condition variables, semaphores, mutexes?
Are there any advantages of using threads over forking processes?
Are there any dis-advantages of using threads over forking processes?
Can you fork a process with multiple threads?
Are there other reasons where fork might be preferable to creating a thread.
How can I find out more?
Pthreads, Part 2: Usage in Practice
Pthreads, Part 2: Usage in Practice
