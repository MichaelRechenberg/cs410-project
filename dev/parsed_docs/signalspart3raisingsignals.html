You already know one way to send a SIG_INT just type CTRL-C 
From the shell you can use kill (if you know the process id) and killall (if you know the process name)
killall is similar except that it matches by program name. The next two example, sends a SIGINT and then SIGKILL to terminate the processes that are running myprogram
Use raise or kill
For non-root processes, signals can only be sent to processes of the same user i.e. you cant just SIGKILL my processes! See kill(2) i.e. man -s2 for more details.
Use pthread_kill
In the example below, the newly created thread executing func will be interrupted by SIGINT
It will kill the entire process. Though individual threads can set a signal mask, the signal disposition (the table of handlers/action performed for each signal) is per-process not per-thread. This means 
sigaction can be called from any thread because you will be setting a signal handler for all threads in the process.
You can choose a handle pending signals asynchronously or synchronously.
Install a signal handler to asynchronously handle signals use sigaction (or, for simple examples, signal ).
To synchronously catch a pending signal use sigwait (which blocks until a signal is delivered) or signalfd (which also blocks and provides a file descriptor that can be read() to retrieve pending signals).
See Signals, Part 4 for an example of using sigwait
How do I send a signal to a process from the shell?
How do I send a signal to a process from the running C program?
How do I send a signal to a specific thread?
Will pthread_kill( threadid, SIGKILL) kill the process or thread?
How do I catch (handle) a signal ?
Signals, Part 3: Raising signals
Signals, Part 3: Raising signals
