To change the "signal disposition" of a process - i.e. what happens when a signal is delivered to your process - use sigaction
You can use system call sigaction to set the current handler for a signal or read the current signal handler for a particular signal.
The sigaction struct includes two callback functions (we will only look at the 'handler' version), a signal mask and a flags field -
Suppose you installed a signal handler for the alarm signal,
The equivalent sigaction code is:
However, we typically may also set the mask and the flags field. The mask is a temporary signal mask used during the signal handler execution. The SA_RESTART flag will automatically restart some (but not all) system calls that otherwise would have returned early (with EINTR error). The latter means we can simplify the rest of code somewhat because a restart loop may no longer be required.
Sigwait can be used to read one pending signal at a time. sigwait is used to synchronously wait for signals, rather than handle them in a callback. A typical use of sigwait in a multi-threaded program is shown below. Notice that the thread signal mask is set first (and will be inherited by new threads). This prevents signals from being delivered so they will remain in a pending state until sigwait is called. Also notice the same set sig_t variable is used by sigwait - except rather than setting the set of blocked signals it is being used as the set of signals that sigwait can catch and return.
One advantage of writing a custom signal handling thread (such as the example below) rather than a callback function is that you can now use many more C library and system functions that otherwise could not be safely used in a signal handler because they are not async signal-safe.
Based on http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_sigmask.html
How and why do I use sigaction ?
How do I convert a signal call into the equivalent sigaction call?
How do I use sigwait?
Signals, Part 4: Sigaction
Signals, Part 4: Sigaction
