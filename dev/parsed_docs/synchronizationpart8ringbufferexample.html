A ring buffer is a simple, usually fixed-sized, storage mechanism where contiguous memory is treated as if it is circular, and two index counters keep track of the current beginning and end of the queue. As  array indexing is not circular, the index counters must wrap around to zero when moved past the end of the array.
As data is added (enqueued) to the front of the queue or removed (dequeued) from tail of the queue, the current items in the buffer form a train that appears to circle the track

A simple (single-threaded) implementation is shown below. Note enqueue and dequeue do not guard against underflow or overflow - it's possible to add an item when when the queue is full and possible to remove an item when the queue is empty. For example if we added 20 integers (1,2,3...) to the queue and did not dequeue any items then values 17,18,19,20 would overwrite the 1,2,3,4. We won't fix this problem right now, instead when we create the multi-threaded version we will ensure enqueue-ing and dequeue-ing threads are blocked while the ring buffer is full or empty respectively.
It's very tempting to write the enqueue or dequeue method in the following compact form (N is the capacity of the buffer e.g. 16):
This method would appear to work (pass simple tests etc) but contains a subtle bug. With enough enqueue operations (a bit more than two billion) the int value of in will overflow and become negative! The modulo (or 'remainder') operator % preserves the sign. Thus you might end up writing into b[-14]  for example! 
A compact form is correct uses bit masking provided N is 2^x (16,32,64,...)
This buffer does not yet prevent buffer underflow or overflow. For that, we'll turn to our multi-threaded attempt that will block a thread until there is space or there is at least one item to remove.
The following code is an incorrect implementation. What will happen? Will enqueue and/or dequeue block? Is mutual exclusion satisfied? Can the buffer underflow? Can the buffer overflow?
For clarity pthread_mutex is shortened to p_m and we assume sem_wait cannot be interrupted.
Before reading on, see how many mistakes you can find. Then determine what would happen if threads called the enqueue and dequeue methods.
The following code is an incorrect implementation. What will happen? Will enqueue and/or dequeue block? Is mutual exclusion satisfied? Can the buffer underflow? Can the buffer overflow?
For clarity pthread_mutex is shortened to p_m and we assume sem_wait cannot be interrupted.
The pseudo-code (pthread_mutex shortened to p_m etc) is shown below.
As the mutex lock is stored in global (static) memory it can be initialized with  PTHREAD_MUTEX_INITIALIZER.If we had allocated space for the mutex on the heap, then we would have used pthread_mutex_init(ptr, NULL)
The enqueue method is shown below. Notice:
 The lock is only held during the critical section (access to the data structure).
 A complete implementation would need to guard against early returns from sem_wait due to POSIX signals.
The dequeue implementation is shown below. Notice the symmetry of the synchronization calls to enqueue. In both cases the functions first wait if the count of spaces or count of items is zero.
What is a ring buffer?
What are gotchas of implementing a Ring Buffer?
Checking a multi-threaded implementation for correctness (Example 1)
Analysis
Checking a multi-threaded implementation for correctness (Example 1)
Correct implementation of a ring buffer
Food for thought
Synchronization, Part 8: Ring Buffer Example
Analysis
Synchronization, Part 8: Ring Buffer Example
